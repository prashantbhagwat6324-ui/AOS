Q.1] Write a C program that print the exit status of a terminated child process
Ans -
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(void) {
    pid_t pid = fork();  // Create a child process
    
    if (pid < 0) {
        // Error in creating child process
        perror("fork failed");
        exit(EXIT_FAILURE);
    }
    
    if (pid == 0) {
        // Child process
        printf("Child process is running...\n");
        // Simulate some work, then exit with a status
        exit(42);  // Exit with a custom status
    } else {
        // Parent process
        int status;
        
        // Wait for the child process to terminate
        waitpid(pid, &status, 0);
        
        // Check if the child process terminated normally
        if (WIFEXITED(status)) {
            // Get the exit status of the child
            int exit_status = WEXITSTATUS(status);
            printf("Child process exited with status: %d\n", exit_status);
        } else {
            // If the child process terminated abnormally
            printf("Child process terminated abnormally\n");
        }
    }
    
    return 0;
}

Q.2]Write a C program which receives file names as command line arguments and display those
filenames in ascending order according to their sizes. I) (e.g $ a.out a.txt b.txt c.txt, â€¦)
Ans -
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

typedef struct {
    char *filename;
    off_t filesize;
} FileInfo;

// Function to compare file sizes
int compareFileSizes(const void *a, const void *b) {
    FileInfo *fileA = (FileInfo *)a;
    FileInfo *fileB = (FileInfo *)b;
    
    if (fileA->filesize < fileB->filesize) return -1;
    else if (fileA->filesize > fileB->filesize) return 1;
    else return 0;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file1> <file2> ...\n", argv[0]);
        return 1;
    }

    FileInfo *files = malloc((argc - 1) * sizeof(FileInfo));
    if (files == NULL) {
        perror("Failed to allocate memory");
        return 1;
    }

    // Collect file names and their sizes
    for (int i = 1; i < argc; i++) {
        struct stat fileStat;
        
        if (stat(argv[i], &fileStat) == -1) {
            perror("Error getting file stats");
            continue;
        }

        files[i - 1].filename = argv[i];
        files[i - 1].filesize = fileStat.st_size;
    }

    // Sort files by size using qsort
    qsort(files, argc - 1, sizeof(FileInfo), compareFileSizes);

    // Display sorted file names and sizes
    printf("Files sorted by size:\n");
    for (int i = 0; i < argc - 1; i++) {
        printf("%s: %ld bytes\n", files[i].filename, files[i].filesize);
    }

    free(files);
    return 0;
}
