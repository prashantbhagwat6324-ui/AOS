Q.1] Generate parent process to write unnamed pipe and will read from it
Ans -
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int pipefds[2];
    pid_t pid;
    char write_message[] = "Hello from Parent!";
    char read_message[100];

    // Create an unnamed pipe
    if (pipe(pipefds) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Create a child process
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid > 0) {  // Parent process
        // Close unused read end of the pipe
        close(pipefds[0]);

        // Parent writes to the pipe
        write(pipefds[1], write_message, strlen(write_message) + 1);
        printf("Parent wrote to pipe: %s\n", write_message);

        // Close the write end after writing
        close(pipefds[1]);

        // Now parent reads from the pipe (used as a demonstration)
        // Reset the message buffer
        memset(read_message, 0, sizeof(read_message));

        // Parent reads from the pipe
        if (read(pipefds[0], read_message, sizeof(read_message)) > 0) {
            printf("Parent read from pipe: %s\n", read_message);
        }

        // Close the read end
        close(pipefds[0]);

    } else {  // Child process
        // Close unused write end of the pipe
        close(pipefds[1]);

        // Child reads from the pipe
        if (read(pipefds[0], read_message, sizeof(read_message)) > 0) {
            printf("Child read from pipe: %s\n", read_message);
        }

        // Close the read end after reading
        close(pipefds[0]);

        // Child writes to the pipe (as an additional action)
        write(pipefds[1], "Hello from Child!", 17);
        printf("Child wrote to pipe: Hello from Child!\n");

        // Close the write end after writing
        close(pipefds[1]);
    }

    return 0;
}

Q.2]Write a C program to Identify the type (Directory, character device, Block device, Regular file,
FIFO or pipe, symbolic link or socket) of given file using stat() system call.
Ans -
#include <stdio.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>

void identify_file_type(const char *filename) {
    struct stat file_stat;

    // Get file status using stat()
    if (stat(filename, &file_stat) == -1) {
        perror("stat");
        exit(EXIT_FAILURE);
    }

    // Identify the file type based on the file mode
    if (S_ISREG(file_stat.st_mode)) {
        printf("%s is a Regular file\n", filename);
    }
    else if (S_ISDIR(file_stat.st_mode)) {
        printf("%s is a Directory\n", filename);
    }
    else if (S_ISCHR(file_stat.st_mode)) {
        printf("%s is a Character device\n", filename);
    }
    else if (S_ISBLK(file_stat.st_mode)) {
        printf("%s is a Block device\n", filename);
    }
    else if (S_ISFIFO(file_stat.st_mode)) {
        printf("%s is a FIFO (Named pipe)\n", filename);
    }
    else if (S_ISLNK(file_stat.st_mode)) {
        printf("%s is a Symbolic link\n", filename);
    }
    else if (S_ISSOCK(file_stat.st_mode)) {
        printf("%s is a Socket\n", filename);
    }
    else {
        printf("%s is an Unknown file type\n", filename);
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    identify_file_type(argv[1]);

    return 0;
}