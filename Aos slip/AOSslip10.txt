Q.1] Write a program that illustrates how to execute two commands concurrently with a pipe.
Ans -
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pipefd[2]; // Pipe file descriptors
    pid_t pid1, pid2;

    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // First child process (ls -l)
    pid1 = fork();
    if (pid1 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid1 == 0) {  // Child process 1 (ls -l)
        // Close the write end of the pipe in the first child
        close(pipefd[0]); 

        // Redirect stdout to the pipe's write end
        dup2(pipefd[1], STDOUT_FILENO);
        close(pipefd[1]); // No need to keep this open after redirecting

        // Execute the first command: ls -l
        execlp("ls", "ls", "-l", NULL);
        perror("execlp");  // If execlp fails
        exit(EXIT_FAILURE);
    }

    // Second child process (grep myfile)
    pid2 = fork();
    if (pid2 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid2 == 0) {  // Child process 2 (grep myfile)
        // Close the write end of the pipe in the second child
        close(pipefd[1]);

        // Redirect stdin to the pipe's read end
        dup2(pipefd[0], STDIN_FILENO);
        close(pipefd[0]); // No need to keep this open after redirecting

        // Execute the second command: grep myfile
        execlp("grep", "grep", "myfile", NULL);
        perror("execlp");  // If execlp fails
        exit(EXIT_FAILURE);
    }

    // Parent process
    close(pipefd[0]);  // Close both ends of the pipe in the parent
    close(pipefd[1]);

    // Wait for both children to finish
    wait(NULL);
    wait(NULL);

    return 0;
}

Q.2] ) Generate parent process to write unnamed pipe and will write into it. Also generate child process
which will read from pipe
Ans -
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int pipefd[2];  // File descriptors for the pipe
    pid_t pid;      // Process ID for fork

    // Create an unnamed pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Fork to create child process
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {  // Child process
        char buffer[100];

        // Close the write-end of the pipe in the child process
        close(pipefd[1]);

        // Read from the pipe
        read(pipefd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);

        // Close the read-end of the pipe after reading
        close(pipefd[0]);
    } else {  // Parent process
        // Close the read-end of the pipe in the parent process
        close(pipefd[0]);

        // Write to the pipe
        const char *message = "Hello from the parent process!";
        write(pipefd[1], message, strlen(message) + 1);  // Include null terminator

        printf("Parent sent: %s\n", message);

        // Close the write-end of the pipe after writing
        close(pipefd[1]);

        // Wait for the child to finish
        wait(NULL);
    }

    return 0;
}
