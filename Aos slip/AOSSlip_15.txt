Slip 15

Q1.Display all the files from current directory whose size is greater that n Bytes Where n is accept
from user.

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    DIR *dir;
    struct dirent *entry;
    struct stat file_stat;
    long size_limit;

    // Check for command-line argument
    if (argc != 2) {
        printf("Usage: %s <size_limit_in_bytes>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // Parse the size limit
    size_limit = atol(argv[1]);
    if (size_limit <= 0) {
        printf("Invalid size limit\n");
        exit(EXIT_FAILURE);
    }

    // Open the current directory
    dir = opendir(".");
    if (dir == NULL) {
        perror("opendir");
        exit(EXIT_FAILURE);
    }

    printf("Files with size greater than %ld bytes:\n", size_limit);

    // Read through the directory and check file sizes
    while ((entry = readdir(dir)) != NULL) {
        // Get the status of the file
        if (stat(entry->d_name, &file_stat) == -1) {
            perror("stat");
            continue;
        }

        // Check if it's a regular file and its size is greater than the limit
        if (S_ISREG(file_stat.st_mode) && file_stat.st_size > size_limit) {
            printf("%s - %.2f KB\n", entry->d_name, file_stat.st_size / 1024.0);
        }
    }

    closedir(dir);
    return 0;
}

gcc slip15_1.c -o slip15_1
./slip15_1

Q2. Write a C program which creates a child process to run linux/ unix command or any user defined
program. The parent process set the signal handler for death of child signal and Alarm signal. If
a child process does not complete its execution in 5 second then parent process kills child process

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

pid_t child_pid;

void handle_child_termination(int sig) {
    int status;
    waitpid(child_pid, &status, 0);
    if (WIFEXITED(status)) {
        printf("Child exited with status: %d\n", WEXITSTATUS(status));
    } else {
        printf("Child terminated abnormally.\n");
    }
    exit(0); // Exit parent after child completes
}

void handle_alarm(int sig) {
    printf("Timeout! Killing child process.\n");
    kill(child_pid, SIGKILL);
    exit(1); // Exit parent after killing child
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <timeout> <command> [args...]\n", argv[0]);
        exit(1);
    }

    int timeout = atoi(argv[1]);
    if (timeout <= 0) {
        fprintf(stderr, "Invalid timeout value.\n");
        exit(1);
    }

    signal(SIGCHLD, handle_child_termination);
    signal(SIGALRM, handle_alarm);

    child_pid = fork();
    if (child_pid < 0) {
        perror("Fork failed");
        exit(1);
    }

    if (child_pid == 0) {
        // Child process
        execvp(argv[2], &argv[2]); // Execute the command
        perror("execvp failed");  // Handle exec failure
        exit(1);
    } else {
        // Parent process
        alarm(timeout); // Set the timeout
        pause();        // Wait for signals
    }

    return 0;
}

gcc slip15_2.c -o slip15_2
./slip15_2 5 sleep 10